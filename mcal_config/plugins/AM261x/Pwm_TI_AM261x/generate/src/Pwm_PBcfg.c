/* ======================================================================
 *   Copyright (C) 2023 Texas Instruments Incorporated
 *
 *   All rights reserved. Property of Texas Instruments Incorporated.
 *   Restricted rights to use, duplicate or disclose this code are
 *   granted through contract.
 *
 *   The program may not be used without the written permission
 *   of Texas Instruments Incorporated or against the terms and conditions
 *   stipulated in the agreement under which this program has been
 *   supplied.
 * ==================================================================== */
[!IF "as:modconf('Pwm')[1]/IMPLEMENTATION_CONFIG_VARIANT = 'VariantPostBuild'"!]
/**

 *  -------------------------------------------------------------------------------------------------------------------
 *  FILE DESCRIPTION
 *  -------------------------------------------------------------------------------------------------------------------
 *         File:  Pwm_PBcfg.c
 *      Project:  TI Sitara MCU AM261x PwmDriver
 *       Module:  DriverPwm
 *    Generator:  EB Tresos
 *
 *  Description:  This component provides services for initialization and control of the microcontroller internal
 *                PWM unit (pulse width modulation). The PWM module generates pulses with variable pulse width.
 *                It allows the selection of the duty cycle and the signal period time.
 *
 *********************************************************************************************************************/


/**********************************************************************************************************************
    Project: [!"$project"!]

    This file is generated by EB Tresos
    Do not modify this file, otherwise the software may behave in unexpected way.
 *********************************************************************************************************************/

#include "Pwm.h"

#ifdef __cplusplus

extern "C" {
#endif

[!AUTOSPACING!]

/* ---- Perform version checking  ----------------------------------------- */
 #if ((PWM_SW_MAJOR_VERSION != ([!"substring-before($moduleSoftwareVer,'.')"!]U))||(PWM_SW_MINOR_VERSION != ([!"substring-before(substring-after($moduleSoftwareVer,'.'),'.')"!]U)))
  #error "Version numbers of Pwm_PBcfg.c and Pwm_Cfg.h are inconsistent!"
#endif

#if ((PWM_CFG_MAJOR_VERSION != ([!"substring-before($moduleSoftwareVer,'.')"!]U))||(PWM_CFG_MINOR_VERSION != ([!"substring-before(substring-after($moduleSoftwareVer,'.'),'.')"!]U)))
  #error "Version numbers of Pwm_PBcfg.c and Pwm_Cfg.h are inconsistent!"
#endif

/*Requirements : SWS_Pwm_60075*/
#define PWM_START_SEC_CONFIG_DATA
#include "Pwm_MemMap.h"

[!MACRO "GetAddress", "ChannelNumber","HwUnitId"!]
[!NOCODE!]
    [!VAR "BaseAddr" = "num:hextoint('0x50000000')"!]
    [!VAR "Channeloffset" = "num:hextoint('0x1000')"!]
    [!VAR "HwUnitOffset" = "num:hextoint('0x40000')"!]
    [!VAR "ChannelBase"  = "num:i($Channeloffset*$ChannelNumber)"!]  

    [!IF "($HwUnitId = 'PWM_CONTROLSS_G0')"!]
      [!VAR "HwUnitBase"   = "num:i($HwUnitOffset*0)"!]
    [!ELSEIF "($HwUnitId = 'PWM_CONTROLSS_G1')"!]
      [!VAR "HwUnitBase"   = "num:i($HwUnitOffset*1)"!]
    [!ENDIF!]
    
    [!CODE!][!"num:inttohex($BaseAddr+$ChannelBase+$HwUnitBase)"!][!ENDCODE!] 
[!ENDNOCODE!]
[!ENDMACRO!]

/* Pwm Channel Configuration parameters */
[!LOOP "as:modconf('Pwm')[1]/PwmChannelConfigSet"!]
CONST(struct Pwm_ConfigType_PC_s, PWM_CONFIG_DATA) [!"@name"!]_PC =
{
    .chCfg =
    {
    [!LOOP "PwmChannel/*"!][!/*Channel Loop */!]
        [[!"@index"!]] =
        {
            .channelId = [!"PwmChannelId"!]U,
            .channelHwId = [!"PwmHWChannelId"!]U,
            .outputCh = (uint32)[!"PwmOutputChSelect"!], /*Output Channel Select*/
        }[!IF "not(node:islast())"!],[!ENDIF!][!CR!][!ENDLOOP!]
    },
};
[!ENDLOOP!][!/*End of PwmChannelConfigSet Loop*/!]

[!VAR "Ticks" = "0"!]
/* Pwm Channel Configuration parameters */
[!LOOP "as:modconf('Pwm')[1]/PwmChannelConfigSet"!]
CONST(struct Pwm_ConfigType_s, PWM_CONFIG_DATA) [!"@name"!] =
{
    .chCfg =
    {
        [!LOOP "PwmChannel/*"!][!/*Channel Loop */!]
        [[!"@index"!]] =
        {
            .baseaddr = [!CALL "GetAddress", "ChannelNumber" = "PwmHWChannelId", "HwUnitId" = "PwmHwUnit"!]UL,
            .instanceClkHz = [!"PwmFunctionalClock"!]U,
            .dutyCycle = [!IF "PwmPeriodDefault = num:f('0')"!][!"num:i('0')"!][!ELSE!][!"num:inttohex(PwmDutycycleDefault)"!][!ENDIF!]U,/* Dutycycle */
            [!IF "PwmPeriodDefault != num:f('0')"!]
              [!VAR "Sys_ClkFreq" = "PwmFunctionalClock"!]
                  [!VAR "HsPrescaler" = "(num:i(PwmHSClkPrescaler) * 2)"!]
                  [!IF "$HsPrescaler = num:i('0') "!]
                    [!VAR "HsPrescalerVal" = "1"!]
                  [!ELSE!]
                    [!VAR "HsPrescalerVal" = "num:i($HsPrescaler)"!]
                  [!ENDIF!]
                  [!VAR "Prescalers" = " (bit:shl(1,num:i(PwmClkPrescaler)) * (num:i($HsPrescalerVal)))"!]
                  [!VAR "Ticks" = " (((num:i($Sys_ClkFreq) div num:i($Prescalers)) div (num:i(round(1 div num:f(PwmPeriodDefault))))) div 2)"!]
                  [!IF "(num:i($Ticks) > num:hextoint('0xffff'))"!][!ERROR "Configured Period is not possible or Invalid, please refer 'Configurable Interfaces' section in Pwm User guide for details!!"!][!ENDIF!]
                  [!IF "(num:f($Ticks) - floor(num:f($Ticks)))  > 0"!][!WARNING "Configured Period is not integer, please refer 'Configurable Interfaces' section in Pwm User guide for details"!][!ENDIF!]
            [!ENDIF!]
            .hwPeriod = [!IF "PwmPeriodDefault = num:f('0')"!][!"num:i('0')"!][!ELSE!][!"num:i($Ticks)"!][!ENDIF!]U, /* Number of HW Unit ticks value which sets initial period */
            .polarity = [!"PwmPolarity"!],/* Polarity */
            .idleState = [!"PwmIdleState"!],/* Idle State */
            .channelClass = [!"PwmChannelClass/*"!],
            [!IF "PwmChannelClass/* = 'PWM_FIXED_PERIOD_SHIFTED'"!][!ERROR "Configured Channel Class is not supported!!"!][!ENDIF!]
            [!IF "node:empty(PwmChannelClass/*) = 'true'"!][!ERROR "PwmChannelClass is not configured"!][!ENDIF!][!//
            .prescale = [!"PwmClkPrescaler"!], /* prescale */
            .hsPrescale = [!"PwmHSClkPrescaler"!], /*High Speed Clock Divider*/
            .enableHR = [!IF "PwmEnableHighRes = 'true'"!]TRUE[!ELSE!]FALSE[!ENDIF!], /*Enable High Resolution */
#if (PWM_NOTIFICATION_SUPPORTED == STD_ON)
            .notificationHandler = (Pwm_NotifyFuncType)[!IF "PwmNotification/* != ''"!] [!"PwmNotification/*"!][!ELSE!]  NULL_PTR [!ENDIF!], /*Notification Function*/
            [!IF "node:empty(PwmNotification/*) = 'true'"!][!ERROR "PwmNotification is not configured"!][!ENDIF!][!//
#endif
        }[!IF "not(node:islast())"!],[!ENDIF!][!CR!][!ENDLOOP!]
    }[!IF "not(node:islast())"!],[!ENDIF!][!CR!]
};
[!ENDLOOP!][!/*End of PwmChannelConfigSet Loop*/!]

#define PWM_STOP_SEC_CONFIG_DATA
#include "Pwm_MemMap.h"

#ifdef __cplusplus
}
#endif

/**********************************************************************************************************************
 *  END OF FILE: Pwm_PBcfg.c                                                                                          *
 *********************************************************************************************************************/
[!ELSE!]
/* The last generated configuration variant is not 
       PRE-COMPILE variant. Refer Pwm_Cfg.c */
[!ENDIF!]